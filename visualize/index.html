<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link rel="stylesheet" href="style.css" />
        <script src="https://d3js.org/d3.v5.min.js" charset="UTF-8"></script>
        <title>Line Chart</title>
    </head>
    <body>
        <h1>Test</h1>
        <svg class="line-chart"></svg>
        <!-- <script type="module" src="./index.js"></script> -->
        <!-- <script type="module" src="./lib/domUid.js"></script> -->
        <script>
            // ============ dependencies ================================================
            async function remote_fetch(file) {
                const response = await fetch(await file.url());
                if (!response.ok)
                    throw new Error(`Unable to load file: ${file.name}`);
                return response;
            }

            class FileAttachment {
                constructor(url, name) {
                    Object.defineProperties(this, {
                        _url: { value: url },
                        name: { value: name, enumerable: true },
                    });
                }
                async url() {
                    return this._url;
                }
                async blob() {
                    return (await remote_fetch(this)).blob();
                }
                async arrayBuffer() {
                    return (await remote_fetch(this)).arrayBuffer();
                }
                async text() {
                    return (await remote_fetch(this)).text();
                }
                async json() {
                    return (await remote_fetch(this)).json();
                }
                async stream() {
                    return (await remote_fetch(this)).body;
                }
                async image() {
                    const url = await this.url();
                    return new Promise((resolve, reject) => {
                        const i = new Image();
                        if (
                            new URL(url, document.baseURI).origin !==
                            new URL(location).origin
                        ) {
                            i.crossOrigin = "anonymous";
                        }
                        i.onload = () => resolve(i);
                        i.onerror = () =>
                            reject(
                                new Error(`Unable to load file: ${this.name}`)
                            );
                        i.src = url;
                    });
                }
            }

            function NoFileAttachments(name) {
                throw new Error(`File not found: ${name}`);
            }

            function FileAttachments(resolve) {
                return (name) => {
                    const url = resolve((name += "")); // Returns a Promise, string, or null.
                    if (url == null) throw new Error(`File not found: ${name}`);
                    return new FileAttachment(url, name);
                };
            }

            function resolve(name, base) {
                if (/^(\w+:)|\/\//i.test(name)) return name;
                if (/^[.]{0,2}\//i.test(name))
                    return new URL(name, base == null ? location : base).href;
                if (!name.length || /^[\s._]/.test(name) || /\s$/.test(name))
                    throw new Error("illegal name");
                return "https://unpkg.com/" + name;
            }

            var count = 0;
            function domUid(name) {
                return new Id(
                    "O-" + (name == null ? "" : name + "-") + ++count
                );
            }

            function Id(id) {
                this.id = id;
                this.href = new URL(`#${id}`, location) + "";
            }

            Id.prototype.toString = function () {
                return "url(" + this.href + ")";
            };

            var EOL = {},
                EOF = {},
                QUOTE = 34,
                NEWLINE = 10,
                RETURN = 13;

            function objectConverter(columns) {
                return new Function(
                    "d",
                    "return {" +
                        columns
                            .map(function (name, i) {
                                return (
                                    JSON.stringify(name) +
                                    ": d[" +
                                    i +
                                    '] || ""'
                                );
                            })
                            .join(",") +
                        "}"
                );
            }

            function customConverter(columns, f) {
                var object = objectConverter(columns);
                return function (row, i) {
                    return f(object(row), i, columns);
                };
            }

            // Compute unique columns in order of discovery.
            function inferColumns(rows) {
                var columnSet = Object.create(null),
                    columns = [];

                rows.forEach(function (row) {
                    for (var column in row) {
                        if (!(column in columnSet)) {
                            columns.push((columnSet[column] = column));
                        }
                    }
                });

                return columns;
            }

            function pad(value, width) {
                var s = value + "",
                    length = s.length;
                return length < width
                    ? new Array(width - length + 1).join(0) + s
                    : s;
            }

            function formatYear(year) {
                return year < 0
                    ? "-" + pad(-year, 6)
                    : year > 9999
                    ? "+" + pad(year, 6)
                    : pad(year, 4);
            }

            function formatDate(date) {
                var hours = date.getUTCHours(),
                    minutes = date.getUTCMinutes(),
                    seconds = date.getUTCSeconds(),
                    milliseconds = date.getUTCMilliseconds();
                return isNaN(date)
                    ? "Invalid Date"
                    : formatYear(date.getUTCFullYear(), 4) +
                          "-" +
                          pad(date.getUTCMonth() + 1, 2) +
                          "-" +
                          pad(date.getUTCDate(), 2) +
                          (milliseconds
                              ? "T" +
                                pad(hours, 2) +
                                ":" +
                                pad(minutes, 2) +
                                ":" +
                                pad(seconds, 2) +
                                "." +
                                pad(milliseconds, 3) +
                                "Z"
                              : seconds
                              ? "T" +
                                pad(hours, 2) +
                                ":" +
                                pad(minutes, 2) +
                                ":" +
                                pad(seconds, 2) +
                                "Z"
                              : minutes || hours
                              ? "T" +
                                pad(hours, 2) +
                                ":" +
                                pad(minutes, 2) +
                                "Z"
                              : "");
            }

            function dsv(delimiter) {
                var reFormat = new RegExp('["' + delimiter + "\n\r]"),
                    DELIMITER = delimiter.charCodeAt(0);

                function parse(text, f) {
                    var convert,
                        columns,
                        rows = parseRows(text, function (row, i) {
                            if (convert) return convert(row, i - 1);
                            (columns = row),
                                (convert = f
                                    ? customConverter(row, f)
                                    : objectConverter(row));
                        });
                    rows.columns = columns || [];
                    return rows;
                }

                function parseRows(text, f) {
                    var rows = [], // output rows
                        N = text.length,
                        I = 0, // current character index
                        n = 0, // current line number
                        t, // current token
                        eof = N <= 0, // current token followed by EOF?
                        eol = false; // current token followed by EOL?

                    // Strip the trailing newline.
                    if (text.charCodeAt(N - 1) === NEWLINE) --N;
                    if (text.charCodeAt(N - 1) === RETURN) --N;

                    function token() {
                        if (eof) return EOF;
                        if (eol) return (eol = false), EOL;

                        // Unescape quotes.
                        var i,
                            j = I,
                            c;
                        if (text.charCodeAt(j) === QUOTE) {
                            while (
                                (I++ < N && text.charCodeAt(I) !== QUOTE) ||
                                text.charCodeAt(++I) === QUOTE
                            );
                            if ((i = I) >= N) eof = true;
                            else if ((c = text.charCodeAt(I++)) === NEWLINE)
                                eol = true;
                            else if (c === RETURN) {
                                eol = true;
                                if (text.charCodeAt(I) === NEWLINE) ++I;
                            }
                            return text.slice(j + 1, i - 1).replace(/""/g, '"');
                        }

                        // Find next delimiter or newline.
                        while (I < N) {
                            if ((c = text.charCodeAt((i = I++))) === NEWLINE)
                                eol = true;
                            else if (c === RETURN) {
                                eol = true;
                                if (text.charCodeAt(I) === NEWLINE) ++I;
                            } else if (c !== DELIMITER) continue;
                            return text.slice(j, i);
                        }

                        // Return last token before EOF.
                        return (eof = true), text.slice(j, N);
                    }

                    while ((t = token()) !== EOF) {
                        var row = [];
                        while (t !== EOL && t !== EOF)
                            row.push(t), (t = token());
                        if (f && (row = f(row, n++)) == null) continue;
                        rows.push(row);
                    }

                    return rows;
                }

                function preformatBody(rows, columns) {
                    return rows.map(function (row) {
                        return columns
                            .map(function (column) {
                                return formatValue(row[column]);
                            })
                            .join(delimiter);
                    });
                }

                function format(rows, columns) {
                    if (columns == null) columns = inferColumns(rows);
                    return [columns.map(formatValue).join(delimiter)]
                        .concat(preformatBody(rows, columns))
                        .join("\n");
                }

                function formatBody(rows, columns) {
                    if (columns == null) columns = inferColumns(rows);
                    return preformatBody(rows, columns).join("\n");
                }

                function formatRows(rows) {
                    return rows.map(formatRow).join("\n");
                }

                function formatRow(row) {
                    return row.map(formatValue).join(delimiter);
                }

                function formatValue(value) {
                    return value == null
                        ? ""
                        : value instanceof Date
                        ? formatDate(value)
                        : reFormat.test((value += ""))
                        ? '"' + value.replace(/"/g, '""') + '"'
                        : value;
                }

                return {
                    parse: parse,
                    parseRows: parseRows,
                    format: format,
                    formatBody: formatBody,
                    formatRows: formatRows,
                    formatRow: formatRow,
                    formatValue: formatValue,
                };
            }

            function saveText(text, filename) {
                var a = document.createElement("a");
                a.setAttribute(
                    "href",
                    "data:text/plain;charset=utf-8," + encodeURIComponent(text)
                );
                a.setAttribute("download", filename);
                a.click();
            }
            // =================================================================================
            let colors = [d3.schemeRdYlBu[3][2], d3.schemeRdYlBu[3][0]];
            let curve = d3.curveStep;
            let margin = { top: 20, right: 20, bottom: 30, left: 30 };
            let height = 600;
            let width = 800;
            const database_api_endpoint = "127.0.0.1:12346/database_api";
            const parseDate = d3.timeParse("%Y%m%d");
            const proxyurl = "http://127.0.0.1:12340/";

            function convert(d) {
                return {
                    date: parseDate(d.date),
                    value0: +d["New York"], // The primary value.
                    value1: +d["San Francisco"], // The secondary comparison value.
                };
            }

            // const data = dsv("\t").parse(
            //     await FileAttachment("./weather.tsv").text(),
            //     (d) => ({
            //         date: parseDate(d.date),
            //         value0: +d["New York"], // The primary value.
            //         value1: +d["San Francisco"], // The secondary comparison value.
            //     })
            // );
            // data.y = "Â°F";

            // send a get request to "http://localhost:12346/database_api/real_pred_15d"
            // fetch(proxyurl + database_api_endpoint + "/real_pred_15d")
            //     .then((response) => response.text())
            //     .then((data) => {
            //         console.log(data);
            //     });

            fetch(proxyurl + database_api_endpoint + "/real_pred_15d")
                .then((response) => response.text())
                .then((text) => {
                    var data = JSON.parse(text).map((d) => {
                        return {
                            date: parseDate(d.date.replace(/[-]/g, "")),
                            value0: +d["value0"], // The Real Stock Price
                            value1: +d["value1"], // The Predicted Stock Price
                        };
                    });
                    console.log(data);

                    let x = d3
                        .scaleTime()
                        .domain(d3.extent(data, (d) => d.date))
                        .range([margin.left, width - margin.right]);
                    let y = d3
                        .scaleLinear()
                        .domain([
                            d3.min(data, (d) => Math.min(d.value0, d.value1)),
                            d3.max(data, (d) => Math.max(d.value0, d.value1)),
                        ])
                        .nice(5)
                        .range([height - margin.bottom, margin.top]);
                    xAxis = (g) =>
                        g
                            .attr(
                                "transform",
                                `translate(0,${height - margin.bottom})`
                            )
                            .call(
                                d3
                                    .axisBottom(x)
                                    .ticks(width / 80)
                                    .tickSizeOuter(0)
                            )
                            .call((g) => g.select(".domain").remove());
                    yAxis = (g) =>
                        g
                            .append("g")
                            .attr("transform", `translate(${margin.left},0)`)
                            .call(d3.axisLeft(y))
                            .call((g) => g.select(".domain").remove())
                            .call((g) =>
                                g
                                    .select(".tick:last-of-type text")
                                    .clone()
                                    .attr("x", 3)
                                    .attr("text-anchor", "start")
                                    .attr("font-weight", "bold")
                                    .text(data.y)
                            );

                    const aboveUid = domUid("above");
                    const belowUid = domUid("below");

                    var chart = d3
                        .select("body")
                        .append("svg")
                        .attr("viewBox", [0, 0, width, height])
                        .datum(data);

                    // var circle = chart
                    //     .append("circle")
                    //     .attr("cx", 150)
                    //     .attr("cy", 75)
                    //     .attr("r", 20)
                    //     .attr("fill", "red")
                    //     .chart.append("g")
                    //     .call(xAxis);
                    chart.append("g").call(yAxis);
                    chart
                        .append("clipPath")
                        .attr("id", aboveUid.id)
                        .append("path")
                        .attr(
                            "d",
                            d3
                                .area()
                                .curve(curve)
                                .x((d) => x(d.date))
                                .y0(0)
                                .y1((d) => y(d.value1))
                        );

                    chart
                        .append("clipPath")
                        .attr("id", belowUid.id)
                        .append("path")
                        .attr(
                            "d",
                            d3
                                .area()
                                .curve(curve)
                                .x((d) => x(d.date))
                                .y0(height)
                                .y1((d) => y(d.value1))
                        );

                    chart
                        .append("path")
                        .attr("clip-path", aboveUid)
                        .attr("fill", colors[1])
                        .attr(
                            "d",
                            d3
                                .area()
                                .curve(curve)
                                .x((d) => x(d.date))
                                .y0(height)
                                .y1((d) => y(d.value0))
                        );

                    chart
                        .append("path")
                        .attr("clip-path", belowUid)
                        .attr("fill", colors[0])
                        .attr(
                            "d",
                            d3
                                .area()
                                .curve(curve)
                                .x((d) => x(d.date))
                                .y0(0)
                                .y1((d) => y(d.value0))
                        );

                    chart
                        .append("path")
                        .attr("fill", "none")
                        .attr("stroke", "black")
                        .attr("stroke-width", 1.5)
                        .attr("stroke-linejoin", "round")
                        .attr("stroke-linecap", "round")
                        .attr(
                            "d",
                            d3
                                .line()
                                .curve(curve)
                                .x((d) => x(d.date))
                                .y((d) => y(d.value0))
                        );
                });

            // d3.tsv("weather.tsv", convert).then(function (data) {
            //     console.log(data);
            //     let x = d3
            //         .scaleTime()
            //         .domain(d3.extent(data, (d) => d.date))
            //         .range([margin.left, width - margin.right]);
            //     let y = d3
            //         .scaleLinear()
            //         .domain([
            //             d3.min(data, (d) => Math.min(d.value0, d.value1)),
            //             d3.max(data, (d) => Math.max(d.value0, d.value1)),
            //         ])
            //         .nice(5)
            //         .range([height - margin.bottom, margin.top]);
            //     xAxis = (g) =>
            //         g
            //             .attr(
            //                 "transform",
            //                 `translate(0,${height - margin.bottom})`
            //             )
            //             .call(
            //                 d3
            //                     .axisBottom(x)
            //                     .ticks(width / 80)
            //                     .tickSizeOuter(0)
            //             )
            //             .call((g) => g.select(".domain").remove());
            //     yAxis = (g) =>
            //         g
            //             .append("g")
            //             .attr("transform", `translate(${margin.left},0)`)
            //             .call(d3.axisLeft(y))
            //             .call((g) => g.select(".domain").remove())
            //             .call((g) =>
            //                 g
            //                     .select(".tick:last-of-type text")
            //                     .clone()
            //                     .attr("x", 3)
            //                     .attr("text-anchor", "start")
            //                     .attr("font-weight", "bold")
            //                     .text(data.y)
            //             );

            //     const aboveUid = domUid("above");
            //     const belowUid = domUid("below");

            //     var chart = d3
            //         .select("body")
            //         .append("svg")
            //         .attr("viewBox", [0, 0, width, height])
            //         .datum(data);

            //     // var circle = chart
            //     //     .append("circle")
            //     //     .attr("cx", 150)
            //     //     .attr("cy", 75)
            //     //     .attr("r", 20)
            //     //     .attr("fill", "red")
            //     //     .chart.append("g")
            //     //     .call(xAxis);
            //     chart.append("g").call(yAxis);
            //     chart
            //         .append("clipPath")
            //         .attr("id", aboveUid.id)
            //         .append("path")
            //         .attr(
            //             "d",
            //             d3
            //                 .area()
            //                 .curve(curve)
            //                 .x((d) => x(d.date))
            //                 .y0(0)
            //                 .y1((d) => y(d.value1))
            //         );

            //     chart
            //         .append("clipPath")
            //         .attr("id", belowUid.id)
            //         .append("path")
            //         .attr(
            //             "d",
            //             d3
            //                 .area()
            //                 .curve(curve)
            //                 .x((d) => x(d.date))
            //                 .y0(height)
            //                 .y1((d) => y(d.value1))
            //         );

            //     chart
            //         .append("path")
            //         .attr("clip-path", aboveUid)
            //         .attr("fill", colors[1])
            //         .attr(
            //             "d",
            //             d3
            //                 .area()
            //                 .curve(curve)
            //                 .x((d) => x(d.date))
            //                 .y0(height)
            //                 .y1((d) => y(d.value0))
            //         );

            //     chart
            //         .append("path")
            //         .attr("clip-path", belowUid)
            //         .attr("fill", colors[0])
            //         .attr(
            //             "d",
            //             d3
            //                 .area()
            //                 .curve(curve)
            //                 .x((d) => x(d.date))
            //                 .y0(0)
            //                 .y1((d) => y(d.value0))
            //         );

            //     chart
            //         .append("path")
            //         .attr("fill", "none")
            //         .attr("stroke", "black")
            //         .attr("stroke-width", 1.5)
            //         .attr("stroke-linejoin", "round")
            //         .attr("stroke-linecap", "round")
            //         .attr(
            //             "d",
            //             d3
            //                 .line()
            //                 .curve(curve)
            //                 .x((d) => x(d.date))
            //                 .y((d) => y(d.value0))
            //         );
            // });

            //end
        </script>
    </body>
</html>
